#include "../cqtx.h"
#include <iostream>

int main(){
  try{


  defaultUnitsc = &stdPhysUnits;
  

  fittable_gaussianfn mygauss;
  mygauss.var("x_0",     "t_0")
         .var("A",       "\\rho_0")
//         .var("\\sigma", "\\sigma")
         .var("x",       "t");
         
  measureseq ps(2);

  QTeXdiagmaster outgr("somegaussian.qda");

  tr1::variate_generator<tr1::mt19937, tr1::normal_distribution<> >
         cdice (std::tr1::mt19937(time(NULL)), std::tr1::normal_distribution<>(0, 1));
  
  tr1::variate_generator<tr1::mt19937, tr1::normal_distribution<> >
         noise (std::tr1::mt19937(time(NULL)), std::tr1::normal_distribution<>(0, 1./43));
  
  int c=3;
  measureseq fnplot(0), frr, fsum;

  while (c < 4) {
    for (measureseq::access p = ps.begin(); p!=ps.end(); ++p) {
      p["\\sigma"] = abs((cdice() + 1.6) * .4*seconds);
      p["t_0"] = cdice() * 4*seconds;
      p["t_{0p}"] = p["t_0"] + cdice() * p["\\sigma"];
      p["\\rho_0"] = abs(cdice() * 1*grams) + abs(cdice() * 2*grams);
    }
    fnplot.clear();
    
    measureseq::access p = ps.begin();
    for (p["t"] = p["t_{0p}"]-7*p["\\sigma"]; p["t"]<p["t_{0p}"]+7*p["\\sigma"]; p["t"]+=.01*p["\\sigma"]){
//    cout << "Status now:\n" << p << endl;
      p["\\rho"] = 0;
      for (measureseq::access q = p; q!=ps.end(); ++q) {
        q["t"] = p["t"];
        p["\\rho"] += mygauss(*q) + noise()*p["\\rho_0"];
      }
//      cout << "p:\n" << *p << "\n\n";
  //    abort();
  //    p["\\rho"].push_upto(0);
      fnplot.push_back(measure(p["\\rho"], p["t"]));//, p["t_0"]));
//    outgr.insertMeasure(p["t"] + p["\\Delta t"], p["\\rho"]);
    }
    outgr.insertCurve(fnplot, captfinder("t"), captfinder("\\rho"), "gaussianssum.qcv", 1);

//  cout << "The correct values:\n" << p << endl; 
    
    montecarlofit fitthisback
             = montecarlofit ( fnplot, captfinder("\\rho"),
                               fittable_multigaussianfn(2).var("x",     "t")
                                                          .var("x_0",     "t_0")
                                                          .var("x_1",     "t_1")
                                                          .var("A_0",       "\\rho_0")
                                                          .var("A_1",       "\\rho_1")
                                                          .var("x_0",       "t_0")
                                                          .var("x_1",       "t_1")       );
    measure fttt = fitthisback.result();
    measureseq fttps = fttt.pack_subscripted();
    
    for (measureseq::access fttp=fttps.begin(); fttp!=fttps.end(); ++fttp){
      fttp["\\sigma"] = abs(fttp["\\sigma"]);
      fttp["t_0"] = fttp["t"];
      fttp["\\rho_0"] = fttp["\\rho"];
      frr.clear();
      cout << "Plot from " << fttp["t_0"]-3*fttp["\\sigma"] << " to " << fttp["t_0"]+3*fttp["\\sigma"] << endl;
      for (fttp["t"] = fttp["t_0"]-3*fttp["\\sigma"]; fttp["t"]<fttp["t_0"]+3*fttp["\\sigma"]; fttp["t"]+=.01*fttp["\\sigma"]){
        fttp["\\rho"] = mygauss(*fttp);
        frr.push_back(*fttp);
      }
      outgr.insertCurve(frr, captfinder("t"), captfinder("\\rho"), "gaussianfitted"+std::string(1,char(c+44))+".qcv", c++ % 4 + 2);
    }
    cout << "fttps:\n" << fttps;
  }

  }catch(const phUnit &phU) {
     cout << "Strange stuff with unit " << phU.uName << endl;
     abort();
  }
  
  
  return (0);
  
}
