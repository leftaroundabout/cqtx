<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CodeGen.CXX.Cqtx.PhqFn</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_CodeGen-CXX-Cqtx-PhqFn.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/CodeGen-CXX-Cqtx-PhqFn.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">cqtx-hsmacros-0.1: Haskell preprocessing / code generation for the cqtx C++ library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>portable</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>(@) sagemuej $ smail.uni-koeln.de</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">CodeGen.CXX.Cqtx.PhqFn</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">General Cqtx code generation
</a></li><li><a href="#g:2">Length-indexed lists
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>While the cqtx library provides quite versatile and <em>in principle</em> very
 low-requirement fitting of general physical functions (namely without the
 need for any gradients etc.), in practise this is hampered by the cumbersomeness
 of defining the fittable_phmsqfn subclasses. The macros in <code>fitfnmacros.h</code> can
 only partially alleviate this: due to the limits of the C preprocessor, most of
 the calculation load needs to be done in also cumbersome C++ templates or,
 more likely, at runtime. At the moment, this is implemented rather poorly, in
 particular the almost bogosort-quality dimensional analysis.
</p><p>This Haskell module does not claim to be an optimal solution, but it produces
 significantly better code than the CPP macros, with very safe and easy invocation.
 In the future this might become a lot more powerful, since it is also possible
 to automatically create highly optimised specialised versions of the functions, e.g.
 squaredistance-calculation on CUDA.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:phqFn">phqFn</a> :: <span class="keyword">forall</span> paramsList. IsolenList paramsList =&gt; <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Data-String.html#t:String">String</a> -&gt; paramsList <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Data-String.html#t:String">String</a> -&gt; (<span class="keyword">forall</span> x. <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:PhqfnDefining">PhqfnDefining</a> x =&gt; paramsList x -&gt; x) -&gt; <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:CqtxCode">CqtxCode</a> ()</li><li class="src short">module <a href="CodeGen-CXX-Code.html">CodeGen.CXX.Code</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:CqtxCode">CqtxCode</a> = ReaderT <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:CqtxConfig">CqtxConfig</a> <a href="CodeGen-CXX-Code.html#t:CXXCode">CXXCode</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:CqtxConfig">CqtxConfig</a> = ()</li><li class="src short"><a href="#v:withDefaultCqtxConfig">withDefaultCqtxConfig</a> ::  <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:CqtxCode">CqtxCode</a> a -&gt; <a href="CodeGen-CXX-Code.html#t:CXXCode">CXXCode</a> a</li><li class="src short"><span class="keyword">class</span> <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#t:Floating">Floating</a> a =&gt; <a href="#t:PhqfnDefining">PhqfnDefining</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:sumOverIdx">sumOverIdx</a> :: PhqVarIndexer -&gt; ((IdxablePhqDefVar a -&gt; a) -&gt; a) -&gt; a</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:IsolenEnd">IsolenEnd</a> a = <a href="#v:P">P</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:IsolenCons">IsolenCons</a> l a = a <a href="#v::.">:.</a> (l a)</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:phqFn" class="def">phqFn</a><a href="src/CodeGen-CXX-Cqtx-PhqFn.html#phqFn" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> paramsList . IsolenList paramsList</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Data-String.html#t:String">String</a></td><td class="doc"><p>Name of the resulting phqFn C++ object
</p></td></tr><tr><td class="src">-&gt; paramsList <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Data-String.html#t:String">String</a></td><td class="doc"><p>Default labels of the parameters
</p></td></tr><tr><td class="src">-&gt; (<span class="keyword">forall</span> x. <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:PhqfnDefining">PhqfnDefining</a> x =&gt; paramsList x -&gt; x)</td><td class="doc"><p>Function definition, as a lambda
</p></td></tr><tr><td class="src">-&gt; <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:CqtxCode">CqtxCode</a> ()</td><td class="doc"><p>C++ class and object code for a cqtx fittable physical function corresponding to the given definition.
</p></td></tr></table></div><div class="doc"><p>Create a physical function that can be fitted to measured data using the cqtx
 algorithms such as <code>evolution_minimizer</code>. The invocation is similar to the
 primitive CPP macros, but type-safe and allows full Haskell syntax in the
 definition &#8211; though this can of course be exploited only so much, since phqfns
 are very limited in their abilities. To make sure these limits are maintained
 we use universally-quantised arguments (which also suits the implementation very
 well).
</p><p>For example, the standard gaussian peak
 <code>&#119860;&#8901;exp(-(&#119909;-&#119909;&#8320;)&#178;/(2&#8901;&#120590;&#178;))</code>
 could be defined thus:
</p><pre>  phqFn &quot;gaussPeak&quot; (&quot;x&quot;:.&quot;x_0&quot;:.&quot;\\sigma&quot;:.&quot;A&quot;:.P)
                 (\ ( x :.  x0 :.  sigma  :. a :.P)
                   -&gt; let q = (x-x0)/sigma in  a * exp(-0.5 * q^2) )
</pre><p>The use of the type-determined&#8211;length lists makes it impossible to accidentally
 give different numbers of parameter bindings and -labels.
</p><p>Avoidance of duplicate calculation, as well as rudimentary optimisation, is taken
 care for by this preprocessor.
</p></div></div><h1 id="g:1">General Cqtx code generation
</h1><div class="top"><p class="src">module <a href="CodeGen-CXX-Code.html">CodeGen.CXX.Code</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CqtxCode" class="def">CqtxCode</a> = ReaderT <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:CqtxConfig">CqtxConfig</a> <a href="CodeGen-CXX-Code.html#t:CXXCode">CXXCode</a><a href="src/CodeGen-CXX-Cqtx-PhqFn.html#CqtxCode" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CqtxConfig" class="def">CqtxConfig</a> = ()<a href="src/CodeGen-CXX-Cqtx-PhqFn.html#CqtxConfig" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:withDefaultCqtxConfig" class="def">withDefaultCqtxConfig</a> ::  <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:CqtxCode">CqtxCode</a> a -&gt; <a href="CodeGen-CXX-Code.html#t:CXXCode">CXXCode</a> a<a href="src/CodeGen-CXX-Cqtx-PhqFn.html#withDefaultCqtxConfig" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Prelude.html#t:Floating">Floating</a> a =&gt; <a name="t:PhqfnDefining" class="def">PhqfnDefining</a> a  <span class="keyword">where</span><a href="src/CodeGen-CXX-Cqtx-PhqFn.html#PhqfnDefining" class="link">Source</a></p><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:sumOverIdx" class="def">sumOverIdx</a> :: PhqVarIndexer -&gt; ((IdxablePhqDefVar a -&gt; a) -&gt; a) -&gt; a<a href="src/CodeGen-CXX-Cqtx-PhqFn.html#sumOverIdx" class="link">Source</a></p></div></div><h1 id="g:2">Length-indexed lists
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:IsolenEnd" class="def">IsolenEnd</a> a <a href="src/CodeGen-CXX-Cqtx-PhqFn.html#IsolenEnd" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:P" class="def">P</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:IsolenEnd" class="caption collapser" onclick="toggleSection('i:IsolenEnd')">Instances</p><div id="section.i:IsolenEnd" class="show"><table><tr><td class="src"><a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:IsolenEnd">IsolenEnd</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Foldable">Foldable</a> <a href="CodeGen-CXX-Cqtx-PhqFn.html#t:IsolenEnd">IsolenEnd</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> (<a href="CodeGen-CXX-Cqtx-PhqFn.html#t:IsolenEnd">IsolenEnd</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:IsolenCons" class="def">IsolenCons</a> l a <a href="src/CodeGen-CXX-Cqtx-PhqFn.html#IsolenCons" class="link">Source</a></p><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src">a <a name="v::." class="def">:.</a> (l a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:IsolenCons" class="caption collapser" onclick="toggleSection('i:IsolenCons')">Instances</p><div id="section.i:IsolenCons" class="show"><table><tr><td class="src"><a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> l =&gt; <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> (<a href="CodeGen-CXX-Cqtx-PhqFn.html#t:IsolenCons">IsolenCons</a> l)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Foldable">Foldable</a> l =&gt; <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Foldable.html#t:Foldable">Foldable</a> (<a href="CodeGen-CXX-Cqtx-PhqFn.html#t:IsolenCons">IsolenCons</a> l)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> a, <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> (l a)) =&gt; <a href="/usr/local/haskell/share/doc/ghc/html/libraries/base-4.6.0.1/Text-Show.html#t:Show">Show</a> (<a href="CodeGen-CXX-Cqtx-PhqFn.html#t:IsolenCons">IsolenCons</a> l a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>